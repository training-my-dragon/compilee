use std::convert::TryInto;
use std::collections::BTreeMap;

use crate::ast::Program;
use crate::ast::SymbolTable;
use crate::ast::Type;
use crate::ast::Statement;
use crate::ast::Expr;
use crate::ast::OpCode;
use crate::ast::LValue;
use crate::ast::RValue;

grammar;

pub Program: Program = {
    <s: Statement*> =>  Program::new(s, SymbolTable::new(BTreeMap::new(), None)),
};

Statement: Statement = {
    FunctionDefinition => Statement::Empty,
    <s: VariableDeclaration> ";" => s,
    <s: Assignment> ";" => s,
    <s: PrintStatement> ";" => s,
    <s: ReadStatement> ";" => s,
    <s: ReturnStatement> ";" => s,
    IfStatement,
    ForStatement,
    StatementBlock,
    "break" ";" => Statement::Break,
    ";" => Statement::Empty,
}

Type: Type = {
    "int" => Type::Int,
    "float" => Type::Float,
    "string" => Type::String,
}

VariableDeclaration: Statement = {
    <decl_type: Type> <id: Identifier> <mut array_size_list: ("[" IntConstant "]")*> => {
        let mut decl_type = decl_type;

        while let Some((_, size, _)) = array_size_list.pop() {
            match size {
                Expr::IntConstant(size) => decl_type = Type::Array(size.try_into().unwrap(), Box::new(decl_type)),
                _ => (),
            };
        }

        Statement::Declaration {id: id, decl_type: decl_type}
    },
}

FunctionDefinition: () = {
    "def" Identifier "(" (FunctionParameter ",")* ")" StatementBlock,
}

FunctionParameter: () = {
    Type Identifier,
}

StatementBlock: Statement = {
    "{" <statement_list: Statement*> "}" => Statement::Block(statement_list, SymbolTable::new(BTreeMap::new(), None)),
}

Assignment: Statement = {
    <left: LValue> "=" <right: RValue> => Statement::Assign(left, right),
}

LValue: LValue = {
    <id: Identifier> <mut access_list: ("[" NumericalExpression "]")*> => {
        let mut lvalue = LValue::Id(id);

        while let Some((_, expr, _)) = access_list.pop() {
            lvalue = LValue::Access(Box::new(lvalue), Box::new(expr));
        }

        lvalue
    },
}

RValue: RValue = {
    NumericalExpression => RValue::Expr(<>),
    Allocation => RValue::Alloc,
}

CompareOp: OpCode = {
    "<" => OpCode::LessThan,
    "<=" => OpCode::LessThanEq,
    ">" => OpCode::GreaterThan,
    ">=" => OpCode::GreaterThanEq,
    "==" => OpCode::Equal,
    "!=" => OpCode::NotEqual,
}

BoolExpression: Expr = {
    <left: NumericalExpression> <op: CompareOp> <right: NumericalExpression> => {
        Expr::BinaryOp(Box::new(left), op, Box::new(right))
    },
    NumericalExpression,
}

NumericalExpression: Expr = {
    <left: Term> "+" <right: NumericalExpression> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::Add,
            Box::new(right),
        )
    },
    <left: Term> "-" <right: NumericalExpression> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::Sub,
            Box::new(right),
        )
    },
    Term,
}

Term: Expr = {
    <left: UnaryExpression> "*" <right: Term> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::Mul,
            Box::new(right),
        )
    },
    <left: UnaryExpression> "/" <right: Term> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::Div,
            Box::new(right),
        )
    },
    <left: UnaryExpression> "%" <right: Term> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::Mod,
            Box::new(right),
        )
    },
    UnaryExpression,
}

UnaryExpression: Expr = {
    "+" <e: Factor> => e,
    "-" <e: Factor> => {
        Expr::UnaryOp(
            OpCode::UnaryMinus,
            Box::new(e),
        )
    },
    Factor,
}

Factor: Expr = {
    IntConstant,
    FloatConstant,
    StringConstant,
    "null" => Expr::NullConstant,
    LValue => Expr::NamedLeaf(<>),
    "(" <e: NumericalExpression> ")" => e,
}

Allocation: () = {
    "new" Type ("[" NumericalExpression "]")+,
}

PrintStatement: Statement = {
    "print" <expr: NumericalExpression> => Statement::Print(expr),
}

ReadStatement: Statement = {
    "read" <lvalue: LValue> => Statement::Read(lvalue),
}

ReturnStatement: Statement = {
    "return" => Statement::Return,
}

IfStatement: Statement = {
    "if" "(" <compare: BoolExpression> ")" <true_block: StatementBlock> => {
        Statement::If {
            compare: compare,
            true_block: Box::new(true_block),
            false_block: None
        }
    },
    "if" "(" <compare: BoolExpression> ")" <true_block: StatementBlock> "else" <false_block: IfStatement> => {
        Statement::If {
            compare: compare,
            true_block: Box::new(true_block),
            false_block: Some(Box::new(false_block)),
        }
    },
    "if" "(" <compare: BoolExpression> ")" <true_block: StatementBlock> "else" <false_block: StatementBlock> => {
        Statement::If {
            compare: compare,
            true_block: Box::new(true_block),
            false_block: Some(Box::new(false_block)),
        }
    },
}

ForStatement: Statement = {
    "for" "(" <init_assign: Assignment> ";" <compare: BoolExpression> ";" <loop_assign: Assignment> ")" <block: StatementBlock> => {
        Statement::For {
            init_assign: Box::new(init_assign),
            compare: compare,
            loop_assign: Box::new(loop_assign),
            block: Box::new(block),
        }
    },
}

Identifier: String = {
    r"[_[:alpha:]][_[:alnum:]]*" => <>.to_string(),
}

IntConstant: Expr = {
    r"[[:digit:]]+" => Expr::IntConstant(<>.parse().unwrap()),
}

FloatConstant: Expr = {
    r"[[:digit:]]+\.[[:digit:]]+" => Expr::FloatConstant(<>.parse().unwrap()),
}

StringConstant: Expr = {
    r#""(([^\\"]|\\.)*)""# => Expr::StringConstant(<>.to_string()),
}

use std::option::Option;
use crate::ast::Statement;
use crate::ast::Expr;
use crate::ast::OpCode;
use crate::ast::LValue;
use crate::ast::RValue;

grammar;

pub Program: Option<Statement> = {
    () => None,
    <s:Statement> => Some(s),
};

Statement: Statement = {
    <s: VariableDeclaration> ";" => Statement::Declaration,
    <s: Assignment> ";" => s,
    <s: PrintStatement> ";" => Statement::Print,
    <s: ReadStatement> ";" => Statement::Read,
    <s: ReturnStatement> ";" => s,
    IfStatement => Statement::If,
    ForStatement => Statement::For,
    StatementBlock,
    "break" ";" => Statement::Break,
    ";" => Statement::Empty,
}

StatementBlock: Statement = {
    "{" <statement_list: Statement*> "}" => Statement::Block(statement_list),
}

VariableDeclaration: () = {
    "int" Identifier ("[" IntConstant "]")*,
    "float" Identifier ("[" IntConstant "]")*,
    "string" Identifier ("[" IntConstant "]")*,
}

Assignment: Statement = {
    <left: LValue> "=" <right: RValue> => Statement::Assign(left, right),
}

LValue: LValue = {
    <id: Identifier> <mut access_list: ("[" Expression "]")*> => {
        let mut lvalue = LValue::Id(id);

        while let Some((_, expr, _)) = access_list.pop() {
            lvalue = LValue::Access(Box::new(lvalue), Box::new(expr));
        }

        lvalue
    },
}

RValue: RValue = {
    Expression => RValue::Expr(<>),
    Allocation => RValue::Alloc,
}

Expression: Expr = {
    <left: NumericalExpression> "<" <right: NumericalExpression> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::LessThan,
            Box::new(right),
        )
    },
    <left: NumericalExpression> "<=" <right: NumericalExpression> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::LessThanEq,
            Box::new(right),
        )
    },
    <left: NumericalExpression> ">"  <right: NumericalExpression> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::GreaterThan,
            Box::new(right),
        )
    },
    <left: NumericalExpression> ">=" <right: NumericalExpression> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::GreaterThanEq,
            Box::new(right),
        )
    },
    <left: NumericalExpression> "==" <right: NumericalExpression> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::Equal,
            Box::new(right),
        )
    },
    <left: NumericalExpression> "!=" <right: NumericalExpression> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::NotEqual,
            Box::new(right),
        )
    },
    NumericalExpression,
}

NumericalExpression: Expr = {
    <left: Term> "+" <right: NumericalExpression> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::Add,
            Box::new(right),
        )
    },
    <left: Term> "-" <right: NumericalExpression> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::Sub,
            Box::new(right),
        )
    },
    Term,
}

Term: Expr = {
    <left: UnaryExpression> "*" <right: Term> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::Mul,
            Box::new(right),
        )
    },
    <left: UnaryExpression> "/" <right: Term> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::Div,
            Box::new(right),
        )
    },
    <left: UnaryExpression> "%" <right: Term> => {
        Expr::BinaryOp(
            Box::new(left),
            OpCode::Mod,
            Box::new(right),
        )
    },
    UnaryExpression,
}

UnaryExpression: Expr = {
    "+" <e: Factor> => e,
    "-" <e: Factor> => {
        Expr::UnaryOp(
            OpCode::UnaryMinus,
            Box::new(e),
        )
    },
    Factor,
}

Factor: Expr = {
    IntConstant,
    FloatConstant,
    StringConstant,
    "null" => Expr::NullConstant,
    LValue => Expr::NamedLeaf(<>),
    "(" <e: NumericalExpression> ")" => e,
}

Allocation: () = {
    "new" "int" ("[" NumericalExpression "]")+,
    "new" "float" ("[" NumericalExpression "]")+,
    "new" "string" ("[" NumericalExpression "]")+,
}

PrintStatement: () = {
    "print" Expression,
}

ReadStatement: () = {
    "read" LValue,
}

ReturnStatement: Statement = {
    "return" => Statement::Return,
}

IfStatement: () = {
    "if" "(" Expression ")" StatementBlock,
    "if" "(" Expression ")" StatementBlock "else" IfStatement,
    "if" "(" Expression ")" StatementBlock "else" StatementBlock,
}

ForStatement: () = {
    "for" "(" Assignment ";" Expression ";" Assignment ")" StatementBlock,
}

Identifier: String = {
    r"[_[:alpha:]][_[:alnum:]]*" => <>.to_string(),
}

IntConstant: Expr = {
    r"[[:digit:]]+" => Expr::IntConstant(<>.parse().unwrap()),
}

FloatConstant: Expr = {
    r"[[:digit:]]+\.[[:digit:]]+" => Expr::FloatConstant(<>.parse().unwrap()),
}

StringConstant: Expr = {
    r#""(([^\\"]|\\.)*)""# => Expr::StringConstant(<>.to_string()),
}
